# Kvizovka - Bug Fixes and Features (Session Summary)

## Date
2026-01-02

## Overview
This document summarizes critical bug fixes and the implementation of the challenge system for Kvizovka.

---

## üêõ Bug Fixes

### 1. Word Validation Bug - "Invalid words: E (Word too short)"

**Problem:**
When placing words that reuse letters from existing words (e.g., placing "STEN" vertically using "E" from horizontal "POEN"), the validator incorrectly reported single-letter words as invalid.

**Root Causes:**

#### Issue A: Word Extraction After Tile Removal
**Location:** `src/game-engine/MoveValidator.ts:147-197`

**Problem:**
```typescript
// BEFORE (BROKEN):
const mainWord = this.findMainWord(placedTiles, direction)  // Returns BoardSquare[] references

// Remove temporary tiles
for (const placed of placedTiles) {
  this.board.removeTile(placed.row, placed.col)  // ‚ùå Tiles removed!
}

// Validate
const invalidWords = this.wordValidator.getInvalidWords([mainWord])  // ‚ùå Reads null tiles!
```

`mainWord` is an array of **references** to BoardSquare objects. When tiles were removed from the board, those squares now had `tile = null`. When `extractWordFromSquares` tried to read the letters, it only found the existing tile "E" (which wasn't removed), resulting in the error "E (Word too short)".

**Solution:**
Extract the word text **before** removing temporary tiles:
```typescript
// AFTER (FIXED):
const mainWord = this.findMainWord(placedTiles, direction)

// Extract word BEFORE removing tiles (while references are still valid)
const wordText = this.wordValidator.extractWordFromSquares(mainWord)

// Now remove tiles
for (const placed of placedTiles) {
  this.board.removeTile(placed.row, placed.col)
}

// Validate using the extracted text
const validationResult = this.wordValidator.validateWord(wordText)
```

#### Issue B: Blocker Tiles Not Stopping Word Scans
**Location:** `src/game-engine/Board.ts:253-296`

**Problem:**
`getTilesInLine()` was treating blocker tiles as regular tiles and scanning through them, when it should **stop at blockers** since they mark word boundaries.

```typescript
// BEFORE (BROKEN):
while (startCol > 0 && !this.isEmpty(row, startCol - 1)) {
  startCol--  // ‚ùå Continues through blockers!
}
```

**Solution:**
Stop scanning when encountering empty squares **OR** blocker tiles:
```typescript
// AFTER (FIXED):
while (startCol > 0 && !this.isEmpty(row, startCol - 1) && !this.isBlocker(row, startCol - 1)) {
  startCol--  // ‚úÖ Stops at blockers
}
```

Applied to all four scan directions (left, right, up, down).

#### Issue C: Cross-Word Validation (Scrabble-Style)
**Location:** `src/game-engine/MoveValidator.ts:147-205`

**Problem:**
The validator was checking ALL words formed (main word + perpendicular cross-words), like in Scrabble. This caused it to validate single letters at intersections.

**Solution:**
In Kvizovka, only validate the **main word being played**. Cross-words are already validated from previous turns:
```typescript
// BEFORE (BROKEN):
const wordsFormed = this.findAllWordsFormed(placedTiles, direction)  // Main + cross-words
const invalidWords = this.wordValidator.getInvalidWords(wordsFormed)

// AFTER (FIXED):
const mainWord = this.findMainWord(placedTiles, direction)  // ONLY main word
const wordText = this.wordValidator.extractWordFromSquares(mainWord)
const validationResult = this.wordValidator.validateWord(wordText)
```

**Files Changed:**
- `src/game-engine/MoveValidator.ts` (lines 147-205)
- `src/game-engine/Board.ts` (lines 253-296)

---

## ‚ú® New Feature: Challenge System

### 2. Automatic Dictionary Validation Removed

**Game Rule:**
In Kvizovka, words are **not** automatically validated against the dictionary when played. Instead, the opponent can **challenge** the word after it's been played.

**Changes:**

#### MoveValidator - Removed Dictionary Checks
**Location:** `src/game-engine/MoveValidator.ts:189-197`

**Before:**
```typescript
// Rule 6: Main word must be valid
const validationResult = this.wordValidator.validateWord(wordText)

if (!validationResult.isValid) {
  return {
    isValid: false,
    reason: `Invalid word: ${validationResult.word} (${validationResult.reason})`,
  }
}
```

**After:**
```typescript
// Rule 6: Check minimum word length
// NOTE: Dictionary validation is NOT automatic in Kvizovka!
// Words can only be challenged by the opponent after being played.
if (wordText.length < MIN_WORD_LENGTH) {
  return {
    isValid: false,
    reason: `Word must be at least ${MIN_WORD_LENGTH} letters long`,
  }
}
```

**Result:** Words are now accepted based only on:
- ‚úÖ Minimum 4-letter length
- ‚úÖ Forms a valid line (horizontal/vertical)
- ‚úÖ Connects to existing tiles
- ‚úÖ First move touches center
- ‚ùå ~~Dictionary validation~~ (removed - only via challenge)

### 3. Challenge Mechanism Implementation

#### Game Store State
**Location:** `src/store/gameStore.ts:75-82`

**Added State:**
```typescript
/**
 * Last played word (can be challenged by opponent)
 */
lastPlayedWord: {
  word: string
  playerIndex: number
  moveIndex: number
} | null
```

**Purpose:** Tracks the most recent word so the opponent can challenge it.

#### MoveValidator Enhancement
**Location:** `src/game-engine/MoveValidator.ts:27-52`

**Added to Result:**
```typescript
export interface MoveValidationResult {
  // ... existing fields

  /**
   * The word text (for challenges)
   */
  wordText?: string
}
```

**Returns word text** so the game store can save it for challenges.

#### Challenge Action
**Location:** `src/store/gameStore.ts:594-651`

**New Action:**
```typescript
challengeLastWord: () => { success: boolean; word: string; reason: string } | null
```

**Logic:**
1. Get `lastPlayedWord` from state
2. Validate word against dictionary using `WordValidator`
3. **If challenge succeeds** (word is invalid):
   - TODO: Undo the move (remove tiles, restore hand, revert score)
   - Clear `lastPlayedWord`
4. **If challenge fails** (word is valid):
   - Penalize challenger: `timeRemaining -= 180` (3 minutes)
   - Clear `lastPlayedWord`
   - Update game state

#### Time Penalty
**Location:** `src/store/gameStore.ts:635-636`

**Implementation:**
```typescript
// Penalize challenger by reducing their time by 3 minutes (180 seconds)
const currentPlayer = game.players[game.currentPlayerIndex]
currentPlayer.timeRemaining = Math.max(0, currentPlayer.timeRemaining - 180)
```

**Notes:**
- Penalty is exactly **3 minutes** (180 seconds)
- Time cannot go below 0 (`Math.max(0, ...)`)
- Applies to the **current player** (the challenger, not the word player)

### 4. Challenge Button UI

**Location:** `src/components/GameControls/GameControls.tsx:130-173, 193-201`

**Added UI Component:**
```tsx
{canChallenge && (
  <button
    onClick={handleChallenge}
    className="btn text-lg py-4 font-bold bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white shadow-lg animate-pulse"
  >
    ‚ö†Ô∏è Challenge Word: "{lastPlayedWord.word}"
  </button>
)}
```

**Features:**
- **Visibility:** Only shown when opponent just played a word (`canChallenge = lastPlayedWord && isInProgress`)
- **Styling:**
  - Orange-to-red gradient (warning colors)
  - Pulsing animation to draw attention
  - Large, prominent button
- **Confirmation Dialog:**
  ```
  Challenge the word "STEN"?

  ‚ö†Ô∏è Warning: If the word is valid, you will lose 3 minutes from your time!
  ```
- **Result Dialogs:**
  - **Success:** "‚úÖ Challenge successful! The word 'X' is invalid. Reason: Y. The move has been undone."
  - **Failure:** "‚ùå Challenge failed! The word 'X' is valid. You have been penalized 3 minutes."

**Behavior:**
- Button appears immediately after opponent plays a word
- Disappears after:
  - Challenge is made (successful or failed)
  - Current player plays their own word
  - Game is paused/ended

**Files Changed:**
- `src/store/gameStore.ts` (state, actions, imports)
- `src/game-engine/MoveValidator.ts` (result interface, validation logic)
- `src/components/GameControls/GameControls.tsx` (UI, handlers)

---

## üìä Technical Details

### Validation Flow (Before vs After)

**BEFORE (Automatic Validation):**
```
Player places tiles
  ‚Üì
Validate structure (line, connectivity, length)
  ‚Üì
Validate DICTIONARY ‚Üê ‚ùå Automatic
  ‚Üì
Accept/Reject
```

**AFTER (Challenge-Based):**
```
Player places tiles
  ‚Üì
Validate structure (line, connectivity, length)
  ‚Üì
Accept (no dictionary check)
  ‚Üì
Opponent can challenge
  ‚Üì
IF challenged ‚Üí Validate DICTIONARY
  ‚Üì
Success: Undo move
Failure: Penalize challenger -3 min
```

### Debug Logging Added

**Location:** `src/game-engine/MoveValidator.ts:147-182`

**Logs:**
```typescript
console.log('üîç Move Validation:', {
  placedTilesCount: placedTiles.length,
  positions: placedTiles.map(t => `(${t.row},${t.col})`).join(', '),
  letters: placedTiles.map(t => /* extract letter */).join(''),
  direction: direction
})

console.log('üìù Found main word:', {
  length: mainWord.length,
  word: wordText
})
```

**Purpose:** Helps diagnose validation issues during development.

---

## üêõ Bug Fixes (Continued)

### 4. Premium Field Multipliers Not Applied to Score

**Problem:**
Premium field multipliers (2x, 3x, 4x letter bonuses and 2x word multipliers) were never being applied when tiles were placed on colored squares. All scores were calculated as if tiles were on normal squares.

**Root Cause:**
**Timing issue** in the move execution flow caused `isUsed` flag to be set too early:

1. `gameStore.ts:302` - Tiles placed on board via `boardInstance.setTile()`
2. `Board.ts:149` - `setTile()` immediately marked premium squares as `isUsed = true`
3. `gameStore.ts:312-316` - Score calculated AFTER tiles were already placed
4. `ScoreCalculator.ts:100` - Checked condition: `if (isNewTile && square.premiumField && !square.isUsed)`
5. Since `isUsed` was already `true`, the condition failed and multipliers were never applied

**Incorrect Flow:**
```
Place tiles ‚Üí Mark premium squares as used (isUsed = true)
  ‚Üì
Calculate score ‚Üí Check !isUsed ‚Üí Always false ‚Üí No multipliers applied ‚ùå
```

**Solution:**
Reordered operations to mark premium squares as used AFTER score calculation:

#### Board.ts - Removed Auto-Marking from setTile()
**Location:** `src/game-engine/Board.ts:145-151`

**Before (BROKEN):**
```typescript
square.tile = tile

// If a tile is placed on a premium field, mark it as used
if (tile && square.premiumField && !square.isUsed) {
  square.isUsed = true  // ‚ùå Marked too early!
}

return true
```

**After (FIXED):**
```typescript
square.tile = tile

// NOTE: Premium fields are NOT marked as used here!
// They are marked as used AFTER score calculation in markSquaresAsUsed()
// This ensures multipliers are applied during scoring.

return true
```

#### Board.ts - Added markSquaresAsUsed() Method
**Location:** `src/game-engine/Board.ts:416-439`

**New Method:**
```typescript
/**
 * Mark premium squares as used after tiles are placed
 *
 * @param placedTiles - Tiles that were just placed
 *
 * IMPORTANT: Call this AFTER score calculation!
 * Premium fields must be unmarked during scoring so multipliers apply.
 * After scoring, mark them as used so they don't apply again.
 *
 * Example:
 *   1. Place tiles on board (premium squares still isUsed = false)
 *   2. Calculate score (multipliers applied because !isUsed)
 *   3. Mark squares as used (prevent future multipliers)
 */
markSquaresAsUsed(placedTiles: PlacedTile[]): void {
  for (const placed of placedTiles) {
    const square = this.getSquare(placed.row, placed.col)

    if (square && square.premiumField && !square.isUsed) {
      square.isUsed = true
      console.log(`‚úÖ Marked (${placed.row},${placed.col}) ${square.premiumField} as used`)
    }
  }
}
```

#### gameStore.ts - Call markSquaresAsUsed() After Scoring
**Location:** `src/store/gameStore.ts:310-319`

**Added:**
```typescript
// Calculate score (premium squares are still unmarked, so multipliers apply)
const calculator = new ScoreCalculator()
const scoreBreakdown = calculator.calculateMoveScore(
  validation.wordsFormed || [],
  placedTiles,
  placedTiles.length
)

// Mark premium squares as used (AFTER scoring, so multipliers don't apply again)
boardInstance.markSquaresAsUsed(placedTiles)  // ‚úÖ Marked at correct time
```

**Correct Flow:**
```
Place tiles ‚Üí Premium squares remain isUsed = false
  ‚Üì
Calculate score ‚Üí Check !isUsed ‚Üí True ‚Üí Multipliers applied ‚úÖ
  ‚Üì
Mark premium squares as used ‚Üí Prevents double-application on future turns
```

**Debug Output:**
With existing debug logging in `ScoreCalculator.ts`, you'll now see:
```
üí∞ Score calculation for tile: {
  position: '(8,4)',
  letter: 'K',
  value: 2,
  isNew: true,
  premiumField: 'DOUBLE_LETTER',
  isUsed: false,  // ‚úÖ Now false during scoring
  willApplyMultiplier: true  // ‚úÖ Now true!
}
  ‚úÖ Applied DOUBLE_LETTER: 2 √ó 2 = 4
üí∞ Final score for word "KUƒÜA": { baseScore: 11, wordMultiplier: 1, finalScore: 11 }
‚úÖ Marked (8,4) DOUBLE_LETTER as used
```

**Files Changed:**
- `src/game-engine/Board.ts` (setTile logic, new markSquaresAsUsed method)
- `src/store/gameStore.ts` (call markSquaresAsUsed after scoring)

---

## üêõ Bug Fixes (Continued)

### 5. Blocker Tiles Not Placed Correctly for Words Reusing Letters

**Problem:**
When a word reuses letters from existing words, blocker tiles were not placed at the correct word boundaries. Missing blockers allowed words to be extended incorrectly.

**Example from User:**
1. Player 1: "MEPELA" horizontal - blockers placed correctly ‚úÖ
2. Player 2: "GAPT" vertical through "P" - blockers placed correctly ‚úÖ
3. Player 1: "EGAR" horizontal through "G" - blockers placed correctly ‚úÖ
4. Player 2: "AMEN" vertical through "A" and "E" - **missing blocker above "A"** ‚ùå

**Root Cause:**
The `placeBlockers()` method received only the **newly placed tiles**, not the complete word:

**Broken Flow:**
```
Word "AMEN" played vertically:
- A (reused from "EGAR")
- M (newly placed)
- E (reused from "EGAR")
- N (newly placed)

placeBlockers() receives: [M, N] ‚ùå (only new tiles)
Sorts and finds "first" = M (WRONG!)
Places blocker above M instead of above A
```

**Root Cause Details:**
- `gameStore.ts:307` called `boardInstance.placeBlockers(placedTiles, validation.direction)`
- `placedTiles` only contains newly placed tiles (M, N)
- Method sorted [M, N] and thought M was the first letter
- Blocker placed above M instead of above A (the actual word start)

#### Solution

**Board.ts - Updated placeBlockers() Signature**
**Location:** `src/game-engine/Board.ts:321-378`

**Before (BROKEN):**
```typescript
placeBlockers(placedTiles: PlacedTile[], direction: Direction): void {
  if (placedTiles.length === 0) return

  // Sort tiles to find first and last
  const sorted = [...placedTiles].sort((a, b) => {
    if (direction === 'HORIZONTAL') {
      return a.col - b.col
    } else {
      return a.row - b.row
    }
  })

  const first = sorted[0]  // ‚ùå Only considers new tiles!
  const last = sorted[sorted.length - 1]
  // ...
}
```

**After (FIXED):**
```typescript
placeBlockers(wordSquares: BoardSquare[], direction: Direction): void {
  if (wordSquares.length === 0) return

  // Sort squares to find first and last
  const sorted = [...wordSquares].sort((a, b) => {
    if (direction === 'HORIZONTAL') {
      return a.col - b.col
    } else {
      return a.row - b.row
    }
  })

  const first = sorted[0]  // ‚úÖ Considers entire word!
  const last = sorted[sorted.length - 1]
  // ...
}
```

**Key Changes:**
1. Parameter changed from `PlacedTile[]` to `BoardSquare[]`
2. Accepts complete main word including reused letters
3. Updated documentation with example showing reused letters

**gameStore.ts - Pass Complete Main Word**
**Location:** `src/store/gameStore.ts:305-314`

**Before (BROKEN):**
```typescript
// Place blockers
if (validation.direction) {
  boardInstance.placeBlockers(placedTiles, validation.direction)  // ‚ùå Only new tiles
}
```

**After (FIXED):**
```typescript
// Place blockers around the main word (including reused letters)
if (validation.direction && validation.wordsFormed && validation.wordsFormed.length > 0) {
  const mainWord = validation.wordsFormed[0]  // ‚úÖ Complete word with reused letters
  console.log('üî≤ Placing blockers for main word:', {
    direction: validation.direction,
    wordLength: mainWord.length,
    positions: mainWord.map(sq => `(${sq.row},${sq.col})`).join(', ')
  })
  boardInstance.placeBlockers(mainWord, validation.direction)
}
```

**Debug Logging Added:**
- `gameStore.ts:308-312` - Logs main word info before placing blockers
- `Board.ts:344,354,364,373` - Logs each blocker placement or failure

**Correct Flow:**
```
Word "AMEN" played vertically:
- A (reused from "EGAR")
- M (newly placed)
- E (reused from "EGAR")
- N (newly placed)

placeBlockers() receives: [A, M, E, N] ‚úÖ (complete word from validation.wordsFormed[0])
Sorts and finds "first" = A (CORRECT!)
Places blocker above A ‚úÖ
Places blocker below N ‚úÖ
```

**Debug Output:**
```
üî≤ Placing blockers for main word: {
  direction: 'VERTICAL',
  wordLength: 4,
  positions: '(4,9), (5,9), (6,9), (7,9)'
}
  üî≤ Placed blocker at (3,9) before word
  üî≤ Placed blocker at (8,9) after word
```

**Files Changed:**
- `src/game-engine/Board.ts` (placeBlockers signature, debug logging)
- `src/store/gameStore.ts` (pass complete word, debug logging)

---

## üîß Known Issues / TODOs

### 1. Successful Challenge - Move Undo Not Implemented
**Location:** `src/store/gameStore.ts:625-631`

**Current State:**
```typescript
if (result.success) {
  // Challenge successful - word is invalid
  // TODO: Undo the last move (remove tiles, restore player's hand, revert score)
  console.log('Challenge successful! Word was invalid:', lastPlayedWord.word)

  // Clear the last played word
  set({ lastPlayedWord: null })
}
```

**What's Missing:**
When a challenge succeeds, we need to:
1. Remove tiles from board
2. Restore tiles to player's hand
3. Revert player's score
4. Remove move from history
5. Switch turn back to original player
6. Remove blocker tiles placed around the word

**Priority:** High - This is core functionality for the challenge system.

### 2. Debug Logging in Production
**Location:** `src/game-engine/MoveValidator.ts:147-182`

**Issue:** Console logs are enabled in production build.

**Solution:** Wrap in `if (process.env.NODE_ENV === 'development')` or remove before release.

---

## üìù Testing Checklist

- [x] Place word vertically using letter from horizontal word ‚Üí No "Word too short" error
- [x] Place word horizontally using letter from vertical word ‚Üí No "Word too short" error
- [x] Blocker tiles prevent word extension ‚Üí Words stop at blockers
- [x] Invalid words accepted without challenge ‚Üí Words placed successfully
- [x] Challenge valid word ‚Üí Challenger loses 3 minutes
- [ ] Challenge invalid word ‚Üí Move undone, tiles returned (TODO)
- [x] Challenge button appears after opponent plays word
- [x] Challenge button disappears after challenge or next move
- [x] Time penalty applied correctly (exactly 180 seconds)
- [x] Premium field multipliers applied correctly (2x, 3x, 4x letter; 2x word)
- [x] Premium squares marked as used after scoring (no double-application)
- [x] Scores calculated correctly with multipliers
- [x] Blocker tiles placed at correct word boundaries (including reused letters)
- [x] Blocker tiles placed before first letter of complete word
- [x] Blocker tiles placed after last letter of complete word

---

## üéØ Summary

**What Was Fixed:**
1. ‚úÖ Word validation bug causing false "Word too short" errors (3 root causes)
2. ‚úÖ getTilesInLine now respects blocker tile boundaries
3. ‚úÖ Only main word validated (not cross-words)
4. ‚úÖ Word extraction happens before tile removal
5. ‚úÖ Premium field multipliers now applied correctly to scores
6. ‚úÖ Premium squares timing bug fixed (isUsed flag set after scoring)
7. ‚úÖ Blocker tiles now placed at correct word boundaries (including reused letters)
8. ‚úÖ placeBlockers() signature updated to accept complete word

**What Was Added:**
1. ‚úÖ Challenge system (no automatic dictionary validation)
2. ‚úÖ Challenge button UI with confirmation dialogs
3. ‚úÖ 3-minute time penalty for failed challenges
4. ‚úÖ lastPlayedWord state tracking
5. ‚úÖ Debug logging for move validation
6. ‚úÖ Debug logging for score calculation
7. ‚úÖ Debug logging for blocker placement
8. ‚úÖ Board.markSquaresAsUsed() method

**What Still Needs Work:**
1. ‚ùå Full move undo when challenge succeeds
2. ‚ùå Remove debug logs from production build

**Build Status:** ‚úÖ Successful (188.52 KB)

---

## üì¶ Files Modified

### Game Engine
- `src/game-engine/MoveValidator.ts` - Validation logic, word extraction fix, challenge support
- `src/game-engine/Board.ts` - Blocker boundary detection in getTilesInLine, markSquaresAsUsed method, removed auto-marking from setTile, placeBlockers signature change, blocker placement debug logging
- `src/game-engine/ScoreCalculator.ts` - Added debug logging for score calculation

### State Management
- `src/store/gameStore.ts` - Challenge mechanism, lastPlayedWord state, time penalty, markSquaresAsUsed call after scoring, pass complete word to placeBlockers, blocker placement debug logging

### UI Components
- `src/components/GameControls/GameControls.tsx` - Challenge button, handlers, dialogs

### Styling
- `src/index.css` - Added @theme directive for Tailwind v4 color definitions
- `src/constants/board-config.ts` - Updated premium field positions (user-corrected)

### Total Lines Changed
- **Added:** ~220 lines
- **Modified:** ~100 lines
- **Deleted:** ~45 lines (removed cross-word validation, auto-marking logic)
